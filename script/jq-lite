#!/usr/bin/env perl

use strict;
use warnings;
use JSON::PP;
use IO::File;
use FindBin;
use lib "$FindBin::Bin/../lib";
use JQ::Lite;

# Default: enable color if STDOUT is a terminal
my $use_color = (-t STDOUT);

# Color codes (will be replaced with '' if --no-color is used)
my %COLOR = (
    reset  => "\e[0m",
    prompt => "\e[1;36m",
    info   => "\e[1;33m",
    error  => "\e[1;31m",
    result => "\e[1;32m",
    key    => "\e[1;34m",
    string => "\e[1;32m",
    number => "\e[1;35m",
    bool   => "\e[1;33m",
    null   => "\e[1;90m",
);

# Disable all colors (called if --no-color is given)
sub disable_colors {
    $_ = '' for values %COLOR;
}

# Show help if no arguments are given
if (!@ARGV) {
    print <<'USAGE';
jq-lite - A lightweight jq-like JSON query tool written in pure Perl

Usage:
  jq-lite [options] '.query' [file.json]

Options:
  -r, --raw-output    Print raw strings instead of JSON-encoded values
  -h, --help          Show this help message
      --no-color      Disable colored output

Examples:
  cat users.json | jq-lite '.users[].name'
  jq-lite '.users[] | select(.age > 25)' users.json
  jq-lite -r '.users[] | .name' users.json
  jq-lite '.meta has "version"' config.json
  jq-lite '.items | sort | reverse | first' data.json
USAGE
    exit 0;
}

# Argument parsing
my $raw_output = 0;
my $query;
my $filename;

while (@ARGV) {
    my $arg = shift @ARGV;
    if ($arg eq '--raw-output' || $arg eq '-r') {
        $raw_output = 1;
    }
    elsif ($arg eq '--help' || $arg eq '-h') {
        print <<'USAGE';
jq-lite - A lightweight jq-like JSON query tool written in pure Perl

Usage:
  jq-lite [options] '.query' [file.json]

Options:
  -r, --raw-output    Print raw strings instead of JSON-encoded values
  -h, --help          Show this help message
      --no-color      Disable colored output
USAGE
        exit 0;
    }
    elsif ($arg eq '--no-color') {
        $use_color = 0;
    }
    elsif (!defined $query && $arg =~ /^\./) {
        $query = $arg;
    }
    elsif (!defined $query && !-f $arg) {
        die "Error: Invalid query syntax '$arg'\nUsage: jq-lite [--raw-output|-r] '.query' [file.json]\n";
    }
    elsif (!defined $query) {
        $filename = $arg;
    }
    elsif (!defined $filename) {
        $filename = $arg;
    }
    else {
        die "Usage: jq-lite [--raw-output|-r] '.query' [file.json]\n";
    }
}

# Disable colors if needed
disable_colors() unless $use_color;

# Load JSON from file or STDIN
my $json_text;
if (defined $filename) {
    open my $fh, '<', $filename or die "Cannot open file '$filename': $!\n";
    local $/;
    $json_text = <$fh>;
    close $fh;
} else {
    local $/;
    $json_text = <STDIN>;
}

# Create JQ::Lite instance
my $jq = JQ::Lite->new(raw => $raw_output);

# Pretty-print JSON with color
sub color_json {
    my ($data, $indent) = @_;
    $indent //= 0;
    my $sp = '  ' x $indent;
    my $out = '';

    if (ref($data) eq 'HASH') {
        $out .= "{\n";
        my @keys = sort keys %$data;
        for my $i (0..$#keys) {
            my $k = $keys[$i];
            $out .= $sp . '  ' . $COLOR{key} . "\"$k\"" . $COLOR{reset} . ": ";
            $out .= color_json($data->{$k}, $indent + 1);
            $out .= "," if $i < $#keys;
            $out .= "\n";
        }
        $out .= $sp . "}";
    }
    elsif (ref($data) eq 'ARRAY') {
        $out .= "[\n";
        for my $i (0..$#$data) {
            $out .= $sp . '  ' . color_json($data->[$i], $indent + 1);
            $out .= "," if $i < $#$data;
            $out .= "\n";
        }
        $out .= $sp . "]";
    }
    elsif (!defined $data) {
        $out .= $COLOR{null} . "null" . $COLOR{reset};
    }
    elsif (JSON::PP::is_bool($data)) {
        $out .= $COLOR{bool} . ($data ? "true" : "false") . $COLOR{reset};
    }
    elsif ($data =~ /^-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?$/) {
        $out .= $COLOR{number} . $data . $COLOR{reset};
    }
    else {
        my $escaped = $data;
        $escaped =~ s/"/\\"/g;
        $escaped =~ s/\n/\\n/g;
        $escaped =~ s/\r/\\r/g;
        $escaped =~ s/\t/\\t/g;
        $out .= $COLOR{string} . "\"$escaped\"" . $COLOR{reset};
    }

    return $out;
}

# Output results (with or without color)
sub print_results {
    my @results = @_;
    if ($raw_output) {
        for my $r (@results) {
            print defined($r) && ref($r) eq '' ? "$r\n" : "null\n";
        }
    } else {
        for my $r (@results) {
            print color_json($r), "\n";
        }
    }
}

# Interactive mode (when query is not given)
if (!defined $query) {
    system("stty -icanon -echo");

    $SIG{INT} = sub {
        system("stty sane");
        print "\n[EXIT]\n";
        exit 0;
    };

    my $input = '';
    my @last_results;

    # Initial display (full JSON)
    my $ok = eval {
        @last_results = $jq->run_query($json_text, '.');
        1;
    };
    if (!$ok || !@last_results) {
        my $data = eval { JSON::PP->new->decode($json_text) };
        if ($data) {
            @last_results = ($data);
        }
    }

    system("clear");
    print $COLOR{prompt}, "> $input\n", $COLOR{reset};
    if (@last_results) {
        print_results(@last_results);
    } else {
        print $COLOR{info}, "[INFO] Failed to load initial JSON data.\n", $COLOR{reset};
    }

    print $COLOR{info}, "\nType query (ESC to quit):\n", $COLOR{reset};

    while (1) {
        my $char;
        sysread(STDIN, $char, 1);
        my $ord = ord($char);
        last if $ord == 27;

        if ($ord == 127 || $char eq "\b") {
            chop $input if length($input);
        } else {
            $input .= $char;
        }

        system("clear");
        print $COLOR{prompt}, "> $input\n", $COLOR{reset};

        my @results;
        my $ok = eval {
            @results = $jq->run_query($json_text, $input);
            1;
        };

        if ($ok && @results) {
            @last_results = @results;
        }

        if (!$ok) {
            print $COLOR{info}, "[INFO] Invalid or partial query. Showing last valid results.\n", $COLOR{reset};
        } elsif (!@results) {
            print $COLOR{info}, "[INFO] Query returned no results. Showing last valid results.\n", $COLOR{reset};
        }

        if (@last_results) {
            eval {
                print_results(@last_results);
                1;
            } or do {
                my $e = $@ || 'Unknown error';
                print $COLOR{error}, "[ERROR] Failed to print: $e\n", $COLOR{reset};
            };
        } else {
            print $COLOR{info}, "[INFO] No previous valid results.\n", $COLOR{reset};
        }
    }

    system("stty sane");
    print $COLOR{info}, "\nGoodbye.\n", $COLOR{reset};
    exit 0;
}

# One-shot mode (query was specified)
my @results = eval { $jq->run_query($json_text, $query) };
if ($@) {
    die $COLOR{error} . "[ERROR] Invalid query: $@\n" . $COLOR{reset};
}

if (!@results) {
    warn $COLOR{info} . "[INFO] No results returned for query.\n" . $COLOR{reset};
    exit 1;
}

print_results(@results);
